import numpy as np
import json
import cv2


def FramesFromFeatures(path):
    #[Feature_id, Time, x_coordinate, y_coordinate]

    #List to store all the features read from the text file
    features = []

    with open(path, 'r') as file:
        # Read each line of the file into a list
        lines = file.readlines()
        # Read each line separately
        for line in lines:
            #Convert each word on the line from string to float
            words = (np.array(line.split())).astype(float)
            #Append the list to the features list
            features.append(words)

    #Sort all the features based on the increasing order of the timestamp
    sorted_indices = np.argsort([arr[1] for arr in features])
    sorted_arr_list = [features[i] for i in sorted_indices]
    features = sorted_arr_list


    #Time difference for each frame
    diff = 0.01
    start_time = features[0][1]
    end_time = start_time + diff
    frame_num = 1
    frames = []
    temp_frame = []
    frame_dict = {}

    for feature in features:
        if feature[1] >= start_time and feature[1] <= end_time:
            temp_frame.append(feature)
        else:
            #sort the features based on feature ids
            sorted_indices1 = np.argsort([arr[0] for arr in temp_frame])
            sorted_arr_list1 = [temp_frame[i] for i in sorted_indices1]

            frame_string = 'Frame '+str(frame_num)
            frames.append(np.array([frame_string]))

            dict_list = []

            for f in sorted_arr_list1:
                # Prevent duplicate features
                if frames[-1][0] != f[0]:
                    frames.append(f)
                    dict_list.append(f)
                # In case of duplicates, keep the latest
                elif frames[-1][0] == f[0]:
                    frames.pop(-1)
                    dict_list.pop(-1)
                    frames.append(f)
                    dict_list.append(f)

            
            frame_dict[frame_string] = dict_list
            temp_frame = []
            start_time = feature[1]
            end_time = start_time + diff

            frame_num = frame_num + 1
            
            temp_frame.append(feature)

    for j in range(len(frame_dict)):
        frame_string = 'Frame '+str(j+1)
        for i in range(len(frame_dict[frame_string])):
            frame_dict[frame_string][i] = frame_dict[frame_string][i].tolist()

    return frame_dict

def HomographyEkltFeatures(frame_dict):
    all_homographies = []

    # Print the dictionary to the console
    for i in range(1, len(frame_dict)):
        frame1_str = 'Frame '+str(i)
        frame2_str = 'Frame '+str(i+1)
        frame1 = frame_dict[frame1_str]
        frame2 = frame_dict[frame2_str]

        src_pts = []
        dst_pts = []
        for feature1 in frame1:
            for feature2 in frame2:
                if feature1[0] == feature2[0]:
                    src_pts.append([[feature1[2], feature1[3]]])
                    dst_pts.append([[feature2[2], feature2[3]]])

        src_pts = np.array(src_pts)
        dst_pts = np.array(dst_pts)


        if(len(src_pts) > 8):
            M, _ = cv2.findHomography(dst_pts, src_pts, cv2.RANSAC, 1.0)
            all_homographies.append(np.array(M))
        else:
            print('Bro give me more points')

    return np.array(all_homographies)

#[Feature_id, Time, x_coordinate, y_coordinate]

#Path to the features file generated by EKLT

# folder_name = 'event_files'
# filename = 'slider_close_timescaled.txt'
# path = folder_name + '/' +filename

# frame_dict = FramesFromFeatures(path)
# all_homographies = HomographyEkltFeatures(frame_dict)

# with open('feature_frames/'+filename.split('.')[0]+'_EKLT_homographies.txt', 'w') as f:
#     f.write('[')
#     for item in range(0, len(all_homographies)):
#         f.write("%s" % all_homographies[item])
#         if item != len(all_homographies) - 1:
#             f.write(",\n")
#     f.write(']')